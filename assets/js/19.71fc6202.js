(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{298:function(e,t,n){e.exports=n.p+"assets/img/provider.8012e68d.png"},299:function(e,t,n){e.exports=n.p+"assets/img/_InheritedProviderScope.972b1dca.png"},300:function(e,t,n){e.exports=n.p+"assets/img/too_young_too_simple.8c759b85.jpeg"},338:function(e,t,n){"use strict";n.r(t);var r=n(14),i=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"provider"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#provider"}},[e._v("#")]),e._v(" Provider")]),e._v(" "),t("p",[e._v("一个Flutter官方团队提供的状态管理库。主要功能是在某个节点为所有子节点提供状态共享和状态更新。为我们提供更丰富、更方便的使用Inherited机制的方式。")]),e._v(" "),t("h2",{attrs:{id:"简单使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单使用"}},[e._v("#")]),e._v(" 简单使用")]),e._v(" "),t("ul",[t("li",[e._v("Provider：数据提供者。Provider的实际类型很多，功能上有两大类：不变值和可变值。可变值改变是会通知Provider以及所有子节点rebuild。所以要注意Provider的位置以保证页面流畅度。")]),e._v(" "),t("li",[e._v("Consumer：数据消费者。本身没有什么逻辑，仅提供一个"),t("code",[e._v("context.watch")]),e._v("的封装。")])]),e._v(" "),t("p",[e._v("来个最简单的🌰")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  @override\n  Widget build(BuildContext context) {\n    return Provider(create: (BuildContext context) {\n      return 'ssss';\n    }, child: Consumer<String>(builder: (context, value, child) {\n      return Text(value);\n    }));\n  }\n")])])]),t("h2",{attrs:{id:"流程分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流程分析"}},[e._v("#")]),e._v(" 流程分析")]),e._v(" "),t("h3",{attrs:{id:"普通状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#普通状态"}},[e._v("#")]),e._v(" 普通状态")]),e._v(" "),t("p",[e._v("以Provider为🌰")]),e._v(" "),t("p",[e._v("继承关系\n"),t("img",{attrs:{src:n(298),alt:"继承关系"}})]),e._v(" "),t("p",[e._v("InteritedProvider")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("InheritedProvider({\n    Key? key,\n    Create<T>? create,\n    T Function(BuildContext context, T? value)? update,\n    UpdateShouldNotify<T>? updateShouldNotify,\n    void Function(T value)? debugCheckInvalidValueType,\n    StartListening<T>? startListening,\n    Dispose<T>? dispose,\n    this.builder,\n    bool? lazy,\n    Widget? child,\n  })  : _lazy = lazy,\n        _delegate = _CreateInheritedProvider(\n          create: create,\n          update: update,\n          updateShouldNotify: updateShouldNotify,\n          debugCheckInvalidValueType: debugCheckInvalidValueType,\n          startListening: startListening,\n          dispose: dispose,\n        ),\n        super(key: key, child: child);\n\n  ...\n\n  @override\n  Widget buildWithChild(BuildContext context, Widget? child) {\n    assert(\n      builder != null || child != null,\n      '$runtimeType used outside of MultiProvider must specify a child',\n    );\n    return _InheritedProviderScope<T>(\n      owner: this,\n      // ignore: no_runtimetype_tostring\n      debugType: kDebugMode ? '$runtimeType' : '',\n      child: builder != null\n          ? Builder(\n              builder: (context) => builder!(context, child),\n            )\n          : child!,\n    );\n  }\n\n")])])]),t("p",[e._v("Provider并不是InteritedWidge的子类，而是一个SingleChildStatelessWidget，所有我们得看"),t("code",[e._v("buildWithChild")]),e._v("方法，进入_InheritedProviderScope。")]),e._v(" "),t("p",[e._v("继承关系\n"),t("img",{attrs:{src:n(299),alt:"继承关系"}}),e._v("\n从这里可以看到_InheritedProviderScope是InteritedWidget。我们这是就能预知后面查找Element是用的就是_InheritedProviderScope。这个类本身并没有啥逻辑，直接来_InheritedProviderScopeElement。依据Interited的设计，_InheritedProviderScopeElement必然是InheritedElement的子类。")]),e._v(" "),t("p",[e._v("_InheritedProviderScopeElement")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  @override\n  bool get hasValue => _delegateState.hasValue;\n\n  @override\n  void markNeedsNotifyDependents() {\n    if (!_isNotifyDependentsEnabled) {\n      return;\n    }\n\n    markNeedsBuild();\n    _shouldNotifyDependents = true;\n  }\n\n  @override\n  void performRebuild() {\n    if (_firstBuild) {\n      _firstBuild = false;\n      _delegateState = widget.owner._delegate.createState()..element = this;\n    }\n    super.performRebuild();\n  }\n")])])]),t("p",[e._v("在这里preformRebuild做了两件事：")]),e._v(" "),t("ol",[t("li",[e._v("实例化了_delegateState。")]),e._v(" "),t("li",[e._v("将自身的引用给_delegateState。\n到这里并没有生产我们需要的值，也就是说没有使用我们传递给Provider的create的那个函数对象。Provider树的生成部分就结束了，下面考虑子树的生成过程。")])]),e._v(" "),t("p",[e._v("Consumer：本身是SingleChildStatelessWidget，很简单。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  @override\n  Widget buildWithChild(BuildContext context, Widget? child) {\n    return builder(\n      context,\n      Provider.of<T>(context),\n      child,\n    );\n  }\n")])])]),t("p",[t("code",[e._v("Provider.of<T>(context)")]),e._v("流程：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  static T of<T>(BuildContext context, {bool listen = true}) {\n  \n    final inheritedElement = _inheritedElementOf<T>(context);\n\n    if (listen) {\n      context.dependOnInheritedElement(inheritedElement);\n    }\n    return inheritedElement.value;//重点分析，这里会到\n  }\n\n  ...\n\n    static _InheritedProviderScopeElement<T> _inheritedElementOf<T>(\n    BuildContext context,\n  ) {\n    _InheritedProviderScopeElement<T>? inheritedElement;\n\n    if (context.widget is _InheritedProviderScope<T>) {\n      // An InheritedProvider<T>'s update tries to obtain a parent provider of\n      // the same type.\n      context.visitAncestorElements((parent) {\n        inheritedElement = parent.getElementForInheritedWidgetOfExactType<\n            _InheritedProviderScope<T>>() as _InheritedProviderScopeElement<T>?;\n        return false;\n      });\n    } else {\n      inheritedElement = context.getElementForInheritedWidgetOfExactType<\n          _InheritedProviderScope<T>>() as _InheritedProviderScopeElement<T>?;\n    }\n\n    if (inheritedElement == null) {\n      throw ProviderNotFoundException(T, context.widget.runtimeType);\n    }\n\n    return inheritedElement!;\n  }\n")])])]),t("p",[t("code",[e._v("inheritedElement.value")]),e._v(" => "),t("code",[e._v("_InheritedProviderScopeElement:_delegateState.value")]),e._v("=>"),t("code",[e._v("_DelegateState:T get value;")]),e._v("如果以Provider的默认构造方法为例的话就是"),t("code",[e._v("_CreateInheritedProviderState:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@override\n  T get value {\n    if (_didInitValue && _value is! T) {\n      throw StateError(\n        'Tried to read a provider that threw during the creation of its value.\\n'\n        'The exception occurred during the creation of type $T.',\n      );\n    }\n    bool? _debugPreviousIsInInheritedProviderCreate;\n    bool? _debugPreviousIsInInheritedProviderUpdate;\n\n    if (!_didInitValue) {\n      _didInitValue = true;\n      if (delegate.create != null) {\n        try {\n          _value = delegate.create!(element!);//这里调用我们传入的方法对象，官方文档的懒加载就体现在这里。值在用到的时候才初始化。\n        } finally {\n          \n        }\n      }\n      if (delegate.update != null) {\n        //先不管\n      }\n    }\n\n    element!._isNotifyDependentsEnabled = false;\n    _removeListener ??= delegate.startListening?.call(element!, _value as T);//这里后面会用到。\n    element!._isNotifyDependentsEnabled = true;\n    assert(delegate.startListening == null || _removeListener != null);\n    return _value as T;\n  }\n")])])]),t("p",[e._v("到这里整个Provider流程就结束了。")]),e._v(" "),t("p",[e._v("以为完了吗？？？\n"),t("img",{attrs:{src:n(300),alt:""}})]),e._v(" "),t("h2",{attrs:{id:"listenableprovider"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#listenableprovider"}},[e._v("#")]),e._v(" ListenableProvider")]),e._v(" "),t("p",[e._v("一个完美的响应式，当数据改变，界面随即改变，不需要额外操作。这里以ListenableProvider为例分析，其他如ChangeNotifierProvider、FutureProvider、StreamProvider、ValueListenableProvider原理类似。")]),e._v(" "),t("p",[e._v("ListenableProvider")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//构造方法多个一个东西_startListening。\n  ListenableProvider({\n    Key? key,\n    required Create<T> create,\n    Dispose<T>? dispose,\n    bool? lazy,\n    TransitionBuilder? builder,\n    Widget? child,\n  }) : super(\n          key: key,\n          startListening: _startListening,\n          create: create,\n          dispose: dispose,\n          lazy: lazy,\n          builder: builder,\n          child: child,\n        );\n  ...\n\n  static VoidCallback _startListening(\n    InheritedContext e,\n    Listenable? value,\n  ) {\n    value?.addListener(e.markNeedsNotifyDependents);\n    return () => value?.removeListener(e.markNeedsNotifyDependents);\n  }\n")])])]),t("p",[e._v("往回看，在_CreateInheritedProviderState的value get中，会调用_startListening这个方法。下面看看markNeedsNotifyDependents是什么，还是往回倒InheritedProviderScopeElement的代码中，markNeedsNotifyDependents()=》markNeedsBuild(),系统方法，标记下帧重绘。那么响应式的到此结束。Future和Stream的类似，只不过不是回调方式不一样。")]),e._v(" "),t("h2",{attrs:{id:"proxyprovider"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#proxyprovider"}},[e._v("#")]),e._v(" ProxyProvider")]),e._v(" "),t("p",[e._v("在前面_CreateInheritedProviderState代码value获取的流程可以发现，一块重要的逻辑是delegate.update，这个属性一直没有赋值。这个值在ProxyProvider会被赋值。流程上依附于签名的流程就很简单了。主要说明下ProxyProvider的设计目的，当一个Provider的值依赖于另一个Provider时，使用ProxyProvider可以方便的做到页面更新(也不是很懂！)。")])])}),[],!1,null,null,null);t.default=i.exports}}]);