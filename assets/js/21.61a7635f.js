(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{295:function(e,t,n){e.exports=n.p+"assets/img/Element_Lifecycle.f018ac63.png"},296:function(e,t,n){e.exports=n.p+"assets/img/State_Lifecycle.d8a5e9c2.png"},321:function(e,t,n){"use strict";n.r(t);var v=n(14),i=Object(v.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[e._v("#")]),e._v(" 生命周期")]),e._v(" "),t("p",[e._v("Element不仅维护Element树，同时还负责维护Render树。所以无论是State生命周期，还是Element生命周期，或者RenderObject生命周期，都是由Element来维护。Element有很多类型，如ComponentElement，RenderObjectElement等，他们在Element生命周期的基础上有不同的扩展，以此来hook State生命周期，RenderObject生命周期。")]),e._v(" "),t("h2",{attrs:{id:"element生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#element生命周期"}},[e._v("#")]),e._v(" Element生命周期")]),e._v(" "),t("p",[e._v("最基础的Element生命周期很简单，只有四种状态："),t("code",[e._v("initial")]),e._v(","),t("code",[e._v("active")]),e._v(","),t("code",[e._v("inactive")]),e._v(","),t("code",[e._v("defunct")]),e._v(".")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("initial")]),e._v(" : Element的默认状态。")]),e._v(" "),t("li",[t("strong",[e._v("active")]),e._v(" : 当Element被插入Element树后的状态，当插入完成，当前Element对应的RenderObject也会被插入树中。")]),e._v(" "),t("li",[t("strong",[e._v("inactive")]),e._v(" : 当Element被移除Element树后的状态，移除完成时，当前Element对应的RenderObject也会被从Render树移除。")]),e._v(" "),t("li",[t("strong",[e._v("defunct")]),e._v(" : Element彻底不可用。当inactive的Element没有在当前frame从新被插入树中触发。")])]),e._v(" "),t("p",[t("code",[e._v("initial")]),e._v("和"),t("code",[e._v("defunct")]),e._v("状态存在的时间都非常短，我们没有机会观察到处于"),t("code",[e._v("initial")]),e._v("状态的Element，因为Framework在创建Element后会立即插入。而"),t("code",[e._v("defunct")]),e._v("状态的Element也不存在任何可达引用，会被垃圾收集器回收。")]),e._v(" "),t("p",[t("code",[e._v("inactive")]),e._v("状态只存在于drawframe期间，在drawFrame后，要么从新插入树=>"),t("code",[e._v("active")]),e._v("，要么彻底移除=>"),t("code",[e._v("defunct")]),e._v(".")]),e._v(" "),t("p",[t("code",[e._v("active")]),e._v("状态是停留在树中时的状态，所有可见元素都是这个状态。")]),e._v(" "),t("p",[t("img",{attrs:{src:n(295),alt:"Element Lifecycle"}})]),e._v(" "),t("h2",{attrs:{id:"state生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#state生命周期"}},[e._v("#")]),e._v(" State生命周期")]),e._v(" "),t("p",[e._v("State的生命周期依赖于Element生命周期，由StatefulElement传递生命周期hook到State。")]),e._v(" "),t("p",[e._v("Element.mount() => _firstBuild() => {initState();didChangeDependencies();}\nElement.unmount() => state.dispose();\nElement.deactivate() => state.deactivate();\nElement.update()=>DidUpdateWidget;")]),e._v(" "),t("ol",[t("li",[e._v("Create: 实例化State，一般我们不关心这个生命周期回调。创建完State后，Element才完成实例化。")]),e._v(" "),t("li",[e._v("InitState: 在Element被挂载到树时触发，一般用于初始化数据，在整个Element生命周期，只会触发一次。")]),e._v(" "),t("li",[e._v("Dependencies：第一次在Element挂载时触发， 后续随着依赖的InheritedWidget发生改变时触发，所以在这里查询InheritedWidget数据是合适的。一般我们也可以在build中查询，毕竟didChangeDependencies后一定会build。但是如果是耗时工作，最好不要放在build。")]),e._v(" "),t("li",[e._v("build：构建Widget树，没啥说的。")]),e._v(" "),t("li",[e._v("DidUpdateWidget：使用新的Widget更新Element时触发。后面一定会触发build。")]),e._v(" "),t("li",[e._v("Deactivate：当Element从树中移除是触发。")]),e._v(" "),t("li",[e._v("Activate：当Element重新插入树中时触发。")]),e._v(" "),t("li",[e._v("Dispose： 当Element被永久移除是触发。")])]),e._v(" "),t("p",[t("img",{attrs:{src:n(296),alt:"State Lifecycle"}})]),e._v(" "),t("h2",{attrs:{id:"renderobject生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#renderobject生命周期"}},[e._v("#")]),e._v(" RenderObject生命周期")]),e._v(" "),t("p",[e._v("Element.mount() => createRenderObject")]),e._v(" "),t("p",[e._v("Element.mount() => attachRenderObject")]),e._v(" "),t("ol",[t("li",[e._v("create")]),e._v(" "),t("li",[e._v("layout")]),e._v(" "),t("li",[e._v("paint")]),e._v(" "),t("li",[e._v("repaint")]),e._v(" "),t("li",[e._v("destory")])])])}),[],!1,null,null,null);t.default=i.exports}}]);