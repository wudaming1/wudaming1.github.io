(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{340:function(n,e,t){"use strict";t.r(e);var i=t(14),r=Object(i.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"sliver-协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sliver-协议"}},[n._v("#")]),n._v(" Sliver 协议")]),n._v(" "),e("p",[n._v("Sliver 协议用于显示滚动组件。viewport 测量 sliver 时使用这套协议，与 box 协议类似，viewport 向 sliver 传递 SliverConstraints，sliver 向 viewport 输出 SliverGeometry。")]),n._v(" "),e("h2",{attrs:{id:"对象介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象介绍"}},[n._v("#")]),n._v(" 对象介绍")]),n._v(" "),e("h3",{attrs:{id:"sliverconstraints"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sliverconstraints"}},[n._v("#")]),n._v(" SliverConstraints")]),n._v(" "),e("p",[n._v("SliverConstraints 描述的是当前 ViewPort 的滚动状态，RenderSliver 使用 SliverConstraints 来测量、布局自己。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class SliverConstraints extends Constraints {\n    /// 主轴方向\n    final AxisDirection axisDirection;\n\n    /// Sliver 沿着主轴从列表的哪个方向插入？枚举类型，正向或反向\n    final GrowthDirection growthDirection;\n\n    /// 用户滑动方向\n    final ScrollDirection userScrollDirection;\n\n    /// 当前Sliver顶部（scrollExtent的起点）滑出Viewport起点的距离\n    final double scrollOffset;\n\n    /// 当前Sliver之前的Sliver占据的scroll总高度，如果不能预估时，该值为double.infinity\n    final double precedingScrollExtent;\n\n    /// 上一个 sliver 覆盖当前 sliver 的大小，通常在 sliver 是 pinned/floating\n    final double overlap;\n\n    /// Viewport剩余的可用绘制范围\n    final double remainingPaintExtent;\n\n    /// 纵轴的长度；如果列表滚动方向是垂直方向，则表示列表宽度。\n    final double crossAxisExtent;\n\n    /// 纵轴排版方向，一般作用与文字排版\n    final AxisDirection crossAxisDirection;\n\n    /// Viewport在主轴方向的长度\n    final double viewportMainAxisExtent;\n\n    /// Viewport 预渲染区域的起点[-Viewport.cacheExtent, 0]\n    final double cacheOrigin;\n\n    /// Viewport加载区域的长度，范围:[viewportMainAxisExtent,viewportMainAxisExtent + Viewport.cacheExtent*2]\n    final double remainingCacheExtent;\n\n}\n")])])]),e("h3",{attrs:{id:"slivergeometry"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#slivergeometry"}},[n._v("#")]),n._v(" SliverGeometry")]),n._v(" "),e("p",[n._v("描述 RenderSliver 所占空间信息。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class SliverGeometry {\n\n    /// 在滑动方向上sliver所占的长度。\n    final double scrollExtent;\n\n    /// sliver的绘制起点，相对与测量结果。\n    final double paintOrigin;\n\n    /// 绘制范围，不影响任何测量\n    fianl double paintExtent;\n\n    /// 当前Sliver可见部分的起点到下一个Sliver可见部分的起点的距离。\n    final double layoutExtent;\n\n    /// 一般为paintExtent，特殊情况下用于计算Viewport的大小。\n    final double maxPaintExtent;\n\n    /// 当Sliver可以收缩时，最大收缩范围。一般slive是pinned或者float。\n    final double maxScrollObstructionExtent;\n\n    /// 纵轴长度\n    final double crossAxisExtent;\n\n    /// 点击范围\n    final double hitTestExtent;\n\n    /// 可见性\n    final bool visible;\n\n    /// 是否被剪切\n    final bool hasVisualOverflow;\n\n    /// 缓存长度\n    final double cacheExtent;\n\n    /// 不知道什么用\n    final double scrollOffsetCorrection;\n\n}\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);