(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{316:function(n,t,i){"use strict";i.r(t);var a=i(14),e=Object(a.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"mixin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mixin"}},[n._v("#")]),n._v(" Mixin")]),n._v(" "),t("p",[n._v("维基百科定义：是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问mixin类的方法、变量而不必成为其子类。")]),n._v(" "),t("p",[n._v("在Dart中，更像是一种带有默认实现的接口。")]),n._v(" "),t("h2",{attrs:{id:"mixin-and-on"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mixin-and-on"}},[n._v("#")]),n._v(" mixin and on")]),n._v(" "),t("p",[n._v("mixin和on关键字用于定义mixin class(混入类)。mixin class不能被实例化，在定义mixin类时，不能定义构造方法。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("abstruct Base { \n    Base(){};\n    void printSelf(){print('Base');}\n    void printSelf2(){print('Base2');}\n}\n\n\nmixin A on Base{\nvoid printSelf(){print('A');}\nvoid printSelf2(){print('A2');}\n}\n\nmixin C on Base{\n    void printSelf(){print('C');}\n}\n\nmixin B on Base, A{\nvoid printSelf2(){print('B2');}\n}\n")])])]),t("p",[n._v("在这里A可以调用Base的方法。B可以调用A和Base的方法。使用o关键字除了赋予了上面的调用能力，还对被混入对象的声明有要求，假设M需要混入A，那么M必须继承Base；假设M需要混入B，那么M必须继承Base，且必须先混入A，及在with的顺序中，A在B前面。")]),n._v(" "),t("h2",{attrs:{id:"extend-and-with"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#extend-and-with"}},[n._v("#")]),n._v(" extend and with")]),n._v(" "),t("p",[n._v("按照with的顺序，会给被混入的类一个线性关系，这关系到同名方法和属性的具体调用。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class M extend Base with A,C,B{\n\n}\n\n")])])]),t("p",[n._v("在M的实例上调用了混入的同名方法(属性也是一样的)时:")]),n._v(" "),t("ol",[t("li",[n._v("调用printSelf时，结果是：C")]),n._v(" "),t("li",[n._v("调用printSelf2时，结果是：B2\n结论是按照线下查找，找到直接使用，线性顺序为：B => C => A => Base。")])]),n._v(" "),t("p",[n._v("在这个混入中，只有C的位置是比较灵活的，A与B有顺序要求。")])])}),[],!1,null,null,null);t.default=e.exports}}]);