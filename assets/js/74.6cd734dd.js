(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{360:function(a,t,r){"use strict";r.r(t);var o=r(14),v=Object(o.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[a._v("#")]),a._v(" 垃圾回收")]),a._v(" "),t("p",[a._v("以hotspot虚拟机为例。使用分带收集算法，主要是不同区域，对象的存活量不一样。")]),a._v(" "),t("h2",{attrs:{id:"虚拟机内存划分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机内存划分"}},[a._v("#")]),a._v(" 虚拟机内存划分")]),a._v(" "),t("p",[a._v("虚拟机把堆内存划分为两块：新生代、老年代。\n虚拟机栈内存叫永久代即方法区。\nMinor GC---新生代垃圾回收：标记复制算法，使用额外的担保空间来使用内存连续。\nMajor GC---老年代垃圾回收：标记整理算法，将活的对象想一端移动保证内存连续。")]),a._v(" "),t("h2",{attrs:{id:"新生代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新生代"}},[a._v("#")]),a._v(" 新生代")]),a._v(" "),t("p",[a._v("包括Eden区、Servivor区。\nEden区：java新对象的出生地(如果新创建的对象占用内存很大，直接分配到老年代)。当Eden内存不够的时候，就会触发MinorGC对新生代进行一次垃圾回收。\nServivor分为两块，一块是空的作为备用空间（ToSpace），另一块用于保存上一次MinorGC过程中的幸存者（FormSpace），当发生Minor GC时，对Eden区和FormSpace中的对象进行清除，并把剩余的对象移动到ToSpace。这个动作之后ToSpace和FormSpace互换。\n对象每经历一次Minor GC，age长一次。")]),a._v(" "),t("h2",{attrs:{id:"老年代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#老年代"}},[a._v("#")]),a._v(" 老年代")]),a._v(" "),t("p",[a._v("老年代对象比较稳定，其中的对象是从新生代移动过来的，发生这两种情况时，虚拟机会把对象移动到老年代：")]),a._v(" "),t("ol",[t("li",[a._v("ToSpace的空间不够存放FormSpace和Eden区的对象。")]),a._v(" "),t("li",[a._v("在Minor GC时发现对象的年纪超过某个数值，例如15。")])]),a._v(" "),t("p",[a._v("当老年代内存不够用是会触发Major GC，进行老年代垃圾回收。")]),a._v(" "),t("h2",{attrs:{id:"永久代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#永久代"}},[a._v("#")]),a._v(" 永久代")]),a._v(" "),t("p",[a._v("永久代存放常量和class对象。\n判断常量废弃：没有引用即可。\n判断类废弃：")]),a._v(" "),t("ol",[t("li",[a._v("类的所有实例被回收。")]),a._v(" "),t("li",[a._v("类的类加载器被回收。")]),a._v(" "),t("li",[a._v("class对象没有引用。")])]),a._v(" "),t("h2",{attrs:{id:"可达性分析算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析算法"}},[a._v("#")]),a._v(" 可达性分析算法")]),a._v(" "),t("p",[a._v("引用计数算法也是一种典型的判断对象存活的算法，但是无法解决循环引用的问题。\n可达性分析算法是图的一个经典算法。hotspot虚拟机采用这种算法来判断对象存活。缺点是会进入“Stop The World”。")]),a._v(" "),t("ol",[t("li",[a._v("枚举GC Roots，此时“Stop The World”。")]),a._v(" "),t("li",[a._v("对每个GC Root运行图的可达性算法。标记可达的对象。")])]),a._v(" "),t("p",[a._v("初始标记:值标记一下GC Roots能直接关联到的对象\n并发标记:对堆中对象进行可达性分析,找出存活的对象,耗时较长\n最终回收:修正在并发标记时因用户程序继续运作而导致标记产生变化的那一部分标记记录\n筛选回收:对各个Region的回收价值和成本进行排序,根据用户期望的GC停顿时间指定回收计划")])])}),[],!1,null,null,null);t.default=v.exports}}]);