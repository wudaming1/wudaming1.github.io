(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{363:function(t,s,a){"use strict";a.r(s);var n=a(14),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"泛型-generic"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#泛型-generic"}},[t._v("#")]),t._v(" 泛型-Generic")]),t._v(" "),s("blockquote",[s("p",[t._v("专家组花费了5年左右的时间来定义规范和测试实现。 ——《java核心技术卷1》第12章-泛型程序设计")])]),t._v(" "),s("blockquote",[s("p",[t._v("“擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。” —— 周志明. 《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》")])]),t._v(" "),s("p",[t._v("设计泛型的原始初衷是为了消除大量强转，在不改变代码的普适性的情况下，在源码中记录更多的提示信息，以便编辑器或者程序员理解代码。")]),t._v(" "),s("p",[t._v("##带来的改变")]),t._v(" "),s("ul",[s("li",[t._v("使用泛型可以避免强制类型转换。")]),t._v(" "),s("li",[t._v("增强程序的可读性。")]),t._v(" "),s("li",[t._v("编译器可以有好的针对泛型做出提示")])]),t._v(" "),s("p",[t._v("##使用位置\n在结构声明处定义泛型变量，在结构内部使用泛型变量。\n结构包括：类、方法。\n泛型变量在实际使用前一定要指定具体类型。不然无法使用。")]),t._v(" "),s("p",[t._v("##限定和通配\n上限限定：extends\n下限限定：super\n限定可以用于修饰通配符，也可以修饰泛型变量。\n通配符：？\n泛型通配符使用在校验泛型参数，具体在参数类型声明中使用，"),s("strong",[t._v("用于解决引用类型和实际类型之间继承关系的匹配。")]),t._v("\n禁止入参类型有通配类型方法的调用")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//get方法的入参不是上线通配，是一个list")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Animal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" animals"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Animal")]),t._v(" animal "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" animals"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//        Dog petter = new Dog();")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//        animals.add((Animal)petter);")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//        Object o = new Object();")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//        animals.add(o)")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//这里animals不能添加任何元素，应为不确定是泛型变量具体是什么类型的。")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//List的add方法入参是上线通配：? extends Animal")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("##泛型的擦除\n无论何时定义一个泛型类型，都会自动提供一个原始类型，原始类型就是泛型类型擦除类型变量，并替换为限定类型。")]),t._v(" "),s("p",[t._v("在调用泛型方法时，如果擦除了返回类型，编译器将插入强制类型转换。存取一个泛型域（全局变量）也一样。")]),t._v(" "),s("p",[t._v("泛型类对象和泛型类的Class对象。\n泛型类的对象完全没有关于泛型的信息。\n泛型类的Class对象记载的泛型的全部信息。")]),t._v(" "),s("h2",{attrs:{id:"擦除引起的冲突"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#擦除引起的冲突"}},[t._v("#")]),t._v(" 擦除引起的冲突")]),t._v(" "),s("p",[t._v("类型擦除与多态发生了冲突：桥方法")]),t._v(" "),s("p",[t._v("##限制")]),t._v(" "),s("ul",[s("li",[t._v("类型参数不能被指定为基本类型。")]),t._v(" "),s("li",[t._v("运行时类型查询只适用于原始类型。")]),t._v(" "),s("li",[t._v("不能创建参数化类型的数组。")]),t._v(" "),s("li",[t._v("不能实例化类型变量。")]),t._v(" "),s("li",[t._v("泛型类的静态上下文中，类型变量无效。不能抛出或者捕获泛型类对象。")])])])}),[],!1,null,null,null);s.default=e.exports}}]);