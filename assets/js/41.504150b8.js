(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{327:function(e,t,n){"use strict";n.r(t);var i=n(14),a=Object(i.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"inheriedwidget"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#inheriedwidget"}},[e._v("#")]),e._v(" InheriedWidget")]),e._v(" "),t("p",[e._v("在Flutter的框架中，使用InheritedWidget来实现Widget之间的信息共享。InheritedWidget被描述为在树中高效向下传递信息的Widget基类。使用InheritedWidget我们能够实现：")]),e._v(" "),t("ol",[t("li",[e._v("为子组件提供数据共享。")]),e._v(" "),t("li",[e._v("为子组件提供响应式更新。")])]),e._v(" "),t("h2",{attrs:{id:"简单实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单实例"}},[e._v("#")]),e._v(" 简单实例")]),e._v(" "),t("p",[e._v("代码片段")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@override\n  Widget buildPage(BuildContext context) {\n    Color a = Theme.of(context).accentColor;\n    ....\n    }\n")])])]),t("p",[e._v("Theme使用_InheritedTheme来完成它的状态共享，_InheritedTheme是InheritedWidget的实现。")]),e._v(" "),t("h2",{attrs:{id:"如何实现数据共享"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何实现数据共享"}},[e._v("#")]),e._v(" 如何实现数据共享")]),e._v(" "),t("h3",{attrs:{id:"如何在element树中存储需要共享的数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何在element树中存储需要共享的数据"}},[e._v("#")]),e._v(" 如何在Element树中存储需要共享的数据")]),e._v(" "),t("p",[e._v("Flutter框架在InheritedElement挂载时将数据关联起来，以首次mount为例：")]),e._v(" "),t("p",[t("img",{attrs:{src:"/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE.png",alt:""}})]),e._v(" "),t("p",[e._v("关键方法：_updateInheritance有两个实现，一个在Element，一个在InheritedElement。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//Element\n  void _updateInheritance() {\n    assert(_lifecycleState == _ElementLifecycle.active);\n    _inheritedWidgets = _parent?._inheritedWidgets;\n  }\n\n//InheritedElement\n  @override\n  void _updateInheritance() {\n    assert(_lifecycleState == _ElementLifecycle.active);\n    final Map<Type, InheritedElement>? incomingWidgets = _parent?._inheritedWidgets;\n    if (incomingWidgets != null)\n      _inheritedWidgets = HashMap<Type, InheritedElement>.from(incomingWidgets);\n    else\n      _inheritedWidgets = HashMap<Type, InheritedElement>();\n    _inheritedWidgets![widget.runtimeType] = this;\n  }  \n\n")])])]),t("p",[e._v("整个流程组合起来实现了一件事：每个Element会维护一张_inheritedWidgets表，这张表包括了从自身开始到Element树Root这条路径上所有InheritedElement的{widget.runtimeType,InheritedElement}映射。")]),e._v(" "),t("h3",{attrs:{id:"子element如何查询到相应数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#子element如何查询到相应数据"}},[e._v("#")]),e._v(" 子Element如何查询到相应数据")]),e._v(" "),t("p",[e._v("BuildContext提供了两种查询接口：")]),e._v(" "),t("ol",[t("li",[t("code",[e._v("T? dependOnInheritedWidgetOfExactType<T extends InheritedWidget>({Object? aspect})")]),e._v("：这种查询方式会让自己在InheritedElement更新时，更新自己的展示。将Element自己添加到了_dependencies。")]),e._v(" "),t("li",[t("code",[e._v("InheritedElement? getElementForInheritedWidgetOfExactType<T extends InheritedWidget>()")]),e._v("：单纯的查询InheritedElement。")])]),e._v(" "),t("p",[e._v("这两种的实现都在Element:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  @override\n  InheritedWidget dependOnInheritedElement(InheritedElement ancestor, { Object? aspect }) {\n    assert(ancestor != null);\n    _dependencies ??= HashSet<InheritedElement>();\n    _dependencies!.add(ancestor);\n    //添加数据依赖，以便InheritedWidget数据发生改变后，更新页面。\n    ancestor.updateDependencies(this, aspect);\n    return ancestor.widget;\n  }\n\n  @override\n  T? dependOnInheritedWidgetOfExactType<T extends InheritedWidget>({Object? aspect}) {\n    assert(_debugCheckStateIsActiveForAncestorLookup());\n    final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T];\n    if (ancestor != null) {\n      assert(ancestor is InheritedElement);\n      return dependOnInheritedElement(ancestor, aspect: aspect) as T;\n    }\n    _hadUnsatisfiedDependencies = true;\n    return null;\n  }\n\n  @override\n  InheritedElement? getElementForInheritedWidgetOfExactType<T extends InheritedWidget>() {\n    assert(_debugCheckStateIsActiveForAncestorLookup());\n    final InheritedElement? ancestor = _inheritedWidgets == null ? null : _inheritedWidgets![T];\n    return ancestor;\n  }\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("abstract class InheritedWidget extends ProxyWidget {\n  const InheritedWidget({ Key? key, required Widget child })\n    : super(key: key, child: child);\n\n  @override\n  InheritedElement createElement() => InheritedElement(this);\n\n  // \n  @protected\n  bool updateShouldNotify(covariant InheritedWidget oldWidget);\n}\n")])])]),t("h3",{attrs:{id:"数据改变如何通知更新"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据改变如何通知更新"}},[e._v("#")]),e._v(" 数据改变如何通知更新")]),e._v(" "),t("p",[e._v("我们知道，所有的Widget都是"),t("code",[e._v("@immutable")]),e._v("。那么改变InheritedWidget的一种方式是父Widget标dirty，用新的数据从新生成InheritedWidget。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/InheritedWidget%E6%95%B0%E6%8D%AE%E5%8F%98%E6%9B%B4.png",alt:""}})]),e._v(" "),t("p",[e._v("最后一个流程：InheritedElement.notifyClients()源码如下，又回到_dependencies找到元素，并标记dirty。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@override\n  void notifyClients(InheritedWidget oldWidget) {\n    assert(_debugCheckOwnerBuildTargetExists('notifyClients'));\n    for (final Element dependent in _dependents.keys) {\n      assert(() {\n        // check that it really is our descendant\n        Element? ancestor = dependent._parent;\n        while (ancestor != this && ancestor != null)\n          ancestor = ancestor._parent;\n        return ancestor == this;\n      }());\n      // check that it really depends on us\n      assert(dependent._dependencies!.contains(this));\n      notifyDependent(oldWidget, dependent);\n    }\n  }\n")])])]),t("p",[e._v("但是使用父Widget标dirty的方式，即使getElementForInheritedWidgetOfExactType也会被刷新，应为从父节点开始，所有的子Element都将用新的Widget刷新。")]),e._v(" "),t("h2",{attrs:{id:"应用实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用实例"}},[e._v("#")]),e._v(" 应用实例")]),e._v(" "),t("h3",{attrs:{id:"theme"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#theme"}},[e._v("#")]),e._v(" Theme")]),e._v(" "),t("p",[e._v("Theme是一个StatelessWidget类型的组件，存储Theme数据的是一个final类型的ThemeData变量。而且ThemeData也被标记为@immutable。那么就很明显了，不存在单独改变某个ThemeData的属性来修改Theme的情况，只能重新构建Theme对象来改变属性。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//将ThemeData与字体相关的本地化配置合并生成新的ThemeData返回给用户。\nstatic ThemeData of(BuildContext context) {\n    final _InheritedTheme? inheritedTheme = context.dependOnInheritedWidgetOfExactType<_InheritedTheme>();\n    final MaterialLocalizations? localizations = Localizations.of<MaterialLocalizations>(context, MaterialLocalizations);\n    final ScriptCategory category = localizations?.scriptCategory ?? ScriptCategory.englishLike;\n    final ThemeData theme = inheritedTheme?.theme.data ?? _kFallbackTheme;\n    return ThemeData.localize(theme, theme.typography.geometryThemeFor(category));\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return _InheritedTheme(\n      theme: this,\n      child: CupertinoTheme(\n        data: MaterialBasedCupertinoThemeData(\n          materialTheme: data,\n        ),\n        child: IconTheme(\n          data: data.iconTheme,\n          child: child,\n        ),\n      ),\n    );\n  }\n\n")])])]),t("h4",{attrs:{id:"theme默认值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#theme默认值"}},[e._v("#")]),e._v(" Theme默认值")]),e._v(" "),t("p",[e._v("在ThemeData的构造方法中有很多判空，并给定默认值："),t("code",[e._v("primarySwatch ??= Colors.blue;")])]),e._v(" "),t("h3",{attrs:{id:"theme的使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#theme的使用"}},[e._v("#")]),e._v(" Theme的使用")]),e._v(" "),t("p",[e._v("从代码结构来看，ThemeData并没有传递性，如果你想用一个新的局部Theme来改变全局Theme的某一个属性是做不到的。新Theme的child不能能查询到全局Theme的ThemeData。")]),e._v(" "),t("ol",[t("li",[e._v("系统默认使用：在很多系统组件中，某些属性如果没有赋值，那么会自动查询Theme赋值，例如TextFormField："),t("code",[e._v("final InputDecoration effectiveDecoration = (decoration ?? const InputDecoration()) .applyDefaults(Theme.of(field.context).inputDecorationTheme);")])]),e._v(" "),t("li",[e._v("主动使用：Theme.of(context)获取ThemeData，直接使用属性即可。")])])])}),[],!1,null,null,null);t.default=a.exports}}]);