# 泛型-Generic
> 专家组花费了5年左右的时间来定义规范和测试实现。 ——《java核心技术卷1》第12章-泛型程序设计



> “擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。” —— 周志明. 《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》
 
  设计泛型的原始初衷是为了消除大量强转，在不改变代码的普适性的情况下，在源码中记录更多的提示信息，以便编辑器或者程序员理解代码。
  


##带来的改变
* 使用泛型可以避免强制类型转换。
* 增强程序的可读性。
* 编译器可以有好的针对泛型做出提示

##使用位置
在结构声明处定义泛型变量，在结构内部使用泛型变量。
结构包括：类、方法。
泛型变量在实际使用前一定要指定具体类型。不然无法使用。

##限定和通配
上限限定：extends
下限限定：super
限定可以用于修饰通配符，也可以修饰泛型变量。
通配符：？
泛型通配符使用在校验泛型参数，具体在参数类型声明中使用，**用于解决引用类型和实际类型之间继承关系的匹配。**
禁止入参类型有通配类型方法的调用

```java
//get方法的入参不是上线通配，是一个list
public void get(List<? extends Animal> animals) {

        Animal animal = animals.get(0);
        //        Dog petter = new Dog();
//        animals.add((Animal)petter);
//        Object o = new Object();
//        animals.add(o)
        //这里animals不能添加任何元素，应为不确定是泛型变量具体是什么类型的。
        //List的add方法入参是上线通配：? extends Animal

    }
```

##泛型的擦除
无论何时定义一个泛型类型，都会自动提供一个原始类型，原始类型就是泛型类型擦除类型变量，并替换为限定类型。

在调用泛型方法时，如果擦除了返回类型，编译器将插入强制类型转换。存取一个泛型域（全局变量）也一样。

泛型类对象和泛型类的Class对象。
泛型类的对象完全没有关于泛型的信息。
泛型类的Class对象记载的泛型的全部信息。


擦除引起的冲突
-------
类型擦除与多态发生了冲突：桥方法

##限制
* 类型参数不能被指定为基本类型。
* 运行时类型查询只适用于原始类型。
* 不能创建参数化类型的数组。
* 不能实例化类型变量。
* 泛型类的静态上下文中，类型变量无效。不能抛出或者捕获泛型类对象。

